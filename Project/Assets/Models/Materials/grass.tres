[gd_resource type="Shader" format=3 uid="uid://c7cshf4c8prbl"]

[resource]
code = "// NOTE: Shader automatically converted from Godot Engine 4.1.stable's StandardMaterial3D.

shader_type spatial;
render_mode blend_mix,depth_draw_opaque,cull_disabled,diffuse_burley,specular_schlick_ggx,world_vertex_coords;

global uniform sampler2D fog_tex;
global uniform vec2 heightmap_tex_size = vec2(1000.0,1000.0);
global uniform float fog_darkness;
global uniform sampler2D building_locs;
global uniform sampler2D ground_tex_main;

varying vec2 pos_uv;

uniform sampler2D depth_texture : source_color, hint_depth_texture;

uniform float sway_intensity: hint_range(0,0.2);
uniform float red_variance : hint_range(0,25);
uniform float green_variance : hint_range(0,25);
uniform float blue_variance : hint_range(0,25);
uniform vec4 albedo : source_color;
uniform float roughness : hint_range(0,1);
uniform sampler2D texture_metallic : hint_default_white,filter_linear_mipmap,repeat_enable;
uniform vec4 metallic_texture_channel;
uniform sampler2D texture_roughness : hint_roughness_r,filter_linear_mipmap,repeat_enable;
uniform float specular;
uniform float metallic;
uniform vec3 uv1_scale;
uniform vec3 uv1_offset;

uniform float height_scaling;

varying float id;

float random(vec2 st){
	return fract(sin(dot(st.xy,
	vec2(12.9898,78.233))) * 43758.5453123);
}

void vertex() {
	//Check for buildings
	vec3 inst_pos = MODEL_MATRIX[3].xyz;
	pos_uv = vec2((inst_pos.x)/heightmap_tex_size.x,(inst_pos.z)/heightmap_tex_size.y)+ vec2(.5);
	vec4 buildings = texture(building_locs, pos_uv);
	// *8 modifies for a standardized 
	vec3 grnd_color = texture(ground_tex_main,pos_uv).rgb;
	COLOR.rgb = grnd_color;
	// Either Hide tree or place it in with waving model
	if(buildings.r > 0.0 || max(max(grnd_color.r,grnd_color.g),grnd_color.b) != grnd_color.g){
		VERTEX.y = -10000.0;
	}else{
		float v_height = VERTEX.y - inst_pos.y; // vertex world height
		if(v_height > 0.0){
			VERTEX.y += v_height*clamp(random(VERTEX.xz),0.25,1.25)*height_scaling;
			float wave = sin(2.0 * PI * TIME + (VERTEX.z+VERTEX.x)*0.8)*v_height;
			float wave2 = sin(2.0 * PI * (TIME + VERTEX.z+VERTEX.x)*2.0)*v_height;
			VERTEX.x += (wave+wave2 *0.4) *sway_intensity;
			VERTEX.z -= (wave-wave2 *0.4)*sway_intensity;
			UV=UV*uv1_scale.xy+uv1_offset.xy;
		}
		id = float(INSTANCE_CUSTOM.x);
	}
}


void fragment() {
	float depth = texture(depth_texture, SCREEN_UV).x;
	vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth);
	vec4 view = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;
	ALPHA = 1.0 - (linear_depth/100.0);
	ALPHA = clamp(ALPHA,0,1);
	vec2 base_uv = UV;
	ALBEDO = albedo.rgb;
	ALBEDO.r += cos(id)/(26.0-red_variance);
	ALBEDO.g += sin(id)/(26.0-green_variance);
	ALBEDO.b += sin(id)/(26.0-blue_variance);
	float metallic_tex = dot(texture(texture_metallic,base_uv),metallic_texture_channel);
	METALLIC = metallic_tex * metallic;
	vec4 roughness_texture_channel = vec4(1.0,0.0,0.0,0.0);
	float roughness_tex = dot(texture(texture_roughness,base_uv),roughness_texture_channel);
	ROUGHNESS = roughness_tex * roughness;
	SPECULAR = specular;
	
	vec4 fog_color = texture(fog_tex, pos_uv);
	if(fog_color.a < 0.1){
		ALBEDO = mix(ALBEDO, vec3 (0,0,0), fog_darkness);
	}
	
	ALBEDO = COLOR.rgb;
}
"
